:awestruct-layout: project-releases-series
:awestruct-project: search
:awestruct-series_version: "6.0"
:hsearch-doc-url-prefix: https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/
:hsearch-jira-url-prefix: https://hibernate.atlassian.net/browse

=== Dependency upgrades

[[orm-version]]
==== Hibernate ORM

Hibernate Search 6 relies on Hibernate ORM 5.4.

Note that only Hibernate ORM 5.4.4.Final or later will work correctly;
5.4.3.Final and earlier will not.

[[lucene-8]]
==== Lucene 8
// Old anchor, kept here to avoid dead links
[[lucene-7]]

The Lucene backend now uses Lucene 8.6.

[[elasticsearch-7]]
==== Elasticsearch 7
// Old anchor, kept here to avoid dead links
[[elasticsearch-6]]

The Elasticsearch backend now works with Elasticsearch 5.6, 6.8 or 7.9.
Support for older versions of Elasticsearch was dropped.

[[api-refresh]]
=== API refresh

A lot of APIs have been changed, for multiple reasons.

==== More consistent API types

The API types consistently use the `Search` prefix: no more mixing `FullText` with `Search` or simply no prefix.

Additionally, the `SearchQuery` type (previously `FullTextQuery`)
now link:{hsearch-doc-url-prefix}#search-dsl-query-fetching-results[defines its own methods]
instead of extending JPA's `TypeQuery`,
highlighting the fact that it targets an index and not a database, and making it a friendlier API.
It is still possible to
link:{hsearch-doc-url-prefix}/#search-dsl-query-object[create an adapter that implements JPA's `TypeQuery`].

==== No more Lucene APIs leaking from Hibernate Search APIs

Hibernate Search APIs now abstract from the Lucene APIs,
so that alternative backends such as Elasticsearch can be used without having Lucene on your classpath.

This should also improve the ability of the Hibernate Search project
to upgrade Lucene as soon as new versions are released.
In Hibernate Search 5, as Lucene was "part of" Hibernate Search APIs,
we were severely limited when we wanted to upgrade to a newer Lucene version,
because any breaking change in Lucene could mean a breaking change for Hibernate Search users, too.
Now that Lucene APIs are no longer necessary to use Hibernate Search,
upgrades should be faster.

==== New Search DSL

The link:{hsearch-doc-url-prefix}#search-dsl[Search DSL] is brand new, with several improvements:

* Ability to link:{hsearch-doc-url-prefix}#search-dsl-predicate[use lambdas]
for more concise query definition,
link:{hsearch-doc-url-prefix}#search-dsl-predicate-boolean-lambda[even when queries are complex].
* Type-safe projections thanks to the brand-new link:{hsearch-doc-url-prefix}#search-dsl-projection[projection DSL].
* Various new features and improvements such as
a new link:{hsearch-doc-url-prefix}#search-dsl-predicate-exists[`exists` predicate],
the ability to link:{hsearch-doc-url-prefix}#search-dsl-predicate-common-overriding-analysis[override analyzers on a per-predicate basis], ...
* Injection of native predicates
(link:{hsearch-doc-url-prefix}#search-dsl-predicate-extensions-lucene-from-lucene-query[`org.apache.lucene.search.Query` for Lucene],
link:{hsearch-doc-url-prefix}#search-dsl-predicate-extensions-elasticsearch-from-json[JSON for Elasticsearch])
within DSL-created predicates.
This is not new for the Lucene integration, but it is for the Elasticsearch integration.
See link:{hsearch-doc-url-prefix}#search-dsl-predicate-extensions[predicate extensions].
* link:{hsearch-doc-url-prefix}search-dsl-query-targeting-multiple[Simpler syntax for predicates when targeting multiple types] in a single query:
instantiating multiple `QueryBuilders` is no longer needed,
Hibernate Search takes into account that multiple types are targeted
and automatically checks that targeted fields are compatible across all targeted indexes.

[[bridge-2.0]]
==== Bridge 2.0

The bridge APIs had to change as part of the API refresh,
so we took this opportunity to overhaul bridge APIs to make bridges more powerful.

The new Bridge APIs are completely different, but with a lot of improvements:

* bridges targeting non-String fields are now first-class citizens:
when targeting bridge-declared, non-String fields in the Search DSL,
you will no longer have to bypass bridges (`.ignoreFieldBridge()`) like you had to in Search 5;
* bridges can link:{hsearch-doc-url-prefix}#mapper-orm-bridge-index-field-type-dsl[define field types precisely],
allowing in particular to pick an analyzer or to enable aggregation (faceting) on a bridge-declared field;
* bridges can link:{hsearch-doc-url-prefix}#mapper-orm-bridge-bridgedelement-dependencies[declare the properties they rely on],
allowing Hibernate Search to reindex less frequently;
* bridges can link:{hsearch-doc-url-prefix}#mapper-orm-bridge-index-field-dsl-dynamic[declare dynamic fields with a precise type]
which the Search DSL will be aware of;
* bridges can be applied with link:{hibernateSearchDocUrl}#mapper-orm-custom-annotations[custom annotations],
allowing clearer mappings, especially when bridges are parameterized;
* and link:{hibernateSearchDocUrl}#mapper-orm-bridge[more].

[[automatic-indexing]]
=== Easier to configure, more efficient automatic indexing

In Hibernate Search 6, automatic indexing is easier to configure correctly:

* `@ContainedIn` is no longer needed: when using `@IndexedEmbedded` on an association,
Hibernate Search 6 infers the inverse side of the association from Hibernate ORM metadata,
which allows it to automatically reindex the class hosting the `@IndexedEmbedded` annotation
when the target of the association changes.
* When the inverse side of an association cannot be resolved,
Hibernate Search 6 will report a mapping error on bootstrap,
allowing you to detect risks of out-of-sync indexes early.
* You can still opt out of automatic reindexing locally
link:{hsearch-doc-url-prefix}#mapper-orm-reindexing-reindexonupdate[using `@IndexingDependency(reindexOnUpdate = ReindexOnUpdate.NO)`].
* Some want more performance with asynchronous automatic indexing,
others prefer data safety and immediate visibility of indexed documents with synchronous automatic indexing.
With Hibernate Search 6, this can all be configured
with a link:{hsearch-doc-url-prefix}#mapper-orm-indexing-automatic-synchronization[single configuration property].

Hibernate Search 6 is also more efficient when processing changes on complex entity graphs.
When a property changes in an entity that is indexed-embedded in multiple other entities,
Hibernate Search 6 will only traverse associations to entities that are actually
affected by the change, based on `@IndexedEmbedded(includePaths = ...)` and other metadata.

[[runtime-joins]]
=== Runtime joins with nested documents

Hibernate Search 6.0 introduces "nested" link:{hsearch-doc-url-prefix}#mapper-orm-indexedembedded-structure[fields]
and link:{hsearch-doc-url-prefix}#search-dsl-predicate-nested[predicates],
similar to the feature with the same name in Elasticsearch.

This means in particular that indexed-embedded entities can be searched much more finely,
for example searching for that one book whose author has a given first name *and* last name.
With the right query, no longer will Hibernate Search return a book authored by "John Smith" and "Jane Doe"
when you were looking for "John Doe"!

For details, see link:{hsearch-doc-url-prefix}#mapper-orm-indexedembedded-storage[`@IndexedEmbedded` storage type]
in the reference documentation.

[[schema-management]]
=== More flexible schema management options

Creating Elasticsearch indexes with the right mapping can be a complex task.
Doing it at the right time in a distributed application, even more so.

Just like Hibernate Search 5, Hibernate Search 6 can manage the schema for you on startup,
but you can also disable automatic schema management and access
link:{hsearch-doc-url-prefix}#mapper-orm-schema-management-manager[dedicated APIs to trigger schema operations on demand].
