= Compatibility policy
Emmanuel Bernard, Yoann Rodiere
:awestruct-layout: community-standard

Your application interacts with Hibernate libraries,
and those in turn interact with third-party software: JDBC drivers, other libraries,
or even REST APIs (Elasticsearch).
When any of these components changes its API, there is a risk that it becomes incompatible.
This page explains how Hibernate projects try to limit incompatible changes.

[TIP]
====
Hibernate projects comply with this compatibility policy on a best effort basis.

For contractually binding warranty, consider paid support:
+++<br />
<div class="ui labels blue">
<a class="ui label" href="/orm/support/"><i class="icon doctor"></i>ORM</a>
<a class="ui label" href="/search/support/"><i class="icon doctor"></i>Search</a>
<a class="ui label" href="/validator/support/"><i class="icon doctor"></i>Validator</a>
<a class="ui label" href="/ogm/support/"><i class="icon doctor"></i>OGM</a>
</div>
+++

====

== Concepts

[[versioning-scheme]]
=== Versioning scheme

The first topic when discussing our view on compatibility is how we name versions and the semantics of that.

Hibernate projects are versioned according to the following scheme:

```
major.minor.micro.qualifier
```

Where:

* `major`, `minor` and `micro` are incrementing integers.
* `qualifier` is `Alpha1`, `Alpha2`, etc., `Beta1`, `Beta2`, etc., for development releases,
`CR1`, `CR2`, etc. for candidate releases
or `Final` for stable releases.

For example: `4.0.0.Final`, `5.2.0.Beta2`, `5.4.0.CR1`.

For the most part we follow the guidelines as defined by
https://community.jboss.org/wiki/JBossProjectVersioning[JBoss Project Versioning Guidelines],
so that is a good background material.

Hibernate, however, applies some additional semantics. Roughly speaking:

* Major updates imply potentially incompatible changes to existing APIs. This may include removal of some APIs.
* Minor updates are simply additions to existing APIs.
* Micro updates are for bugfixes only.
* Alpha/Beta updates are for work in progress and may change newly introduced APIs.

Details can be found further down in <<compatibility-api-spi>>.

[[code-categorization]]
=== Code categorization

We conceptually divide the classes of the codebase into 3 broad categories:

* The API is the set of contracts exposed to the application. For example, `Session#save`.
It is an interface for your application to interact with Hibernate.
This is code that we fully expect to be directly linked to your application bytecode by the compiler.
* An SPI is an "integration point" with Hibernate and the contracts needed to perform those integrations.
It is an interface for frameworks or third-party libraries (caching implementations, ...)
to integrate with Hibernate.
* The internals are classes and code meant only for Hibernate usage internally.

For the most part we try to denote these distinctions through the placement of classes into packages:

* Classes in packages with `internal` or `impl` in the name are internal.
* Classes in packages with `spi` in the name are SPI.
* Classes in packages with neither `internal`, `impl` nor `spi` in the name are API.

NOTE: For Hibernate ORM, grouping code into packages in this manner is an ongoing process and is still incomplete.
The reason we could not do it en masse is, oddly, backwards compatibility.

[[compatibility-api-spi]]
== Compatibility between applications and Hibernate projects

This section discusses the expectations users should have regarding
compatibility between their application and Hibernate projects.

[IMPORTANT]
====
The principles below are guidelines. While we strive to follow them as much as possible,
there are times when exceptions need to be made.

For example, if the design of a small part of the API renders it useless or causes critical bugs,
we may decide to change it incompatibly in a bugfix (micro) release.
====

=== API

API contracts are stable across all releases within a *major* version.

For example, if you develop an application initially using Hibernate ORM version 4.0.0
and the application only relies on the defined APIs,
the expectation is that you can drop in any newer Hibernate 4.x version and it will JustWork.

This is what is called _backwards compatibility_: any changes done in 4.3 (for example)
are done in such a way as to remain compatible with older (backward) versions all the way back to 4.0.

The inverse is something we actually do not guarantee in regards to APIs
and going back to an older version (reverting).
An example here would be developing an application using the natural-id API developed in 4.2
and then trying to drop Hibernate ORM 4.1 or 4.0 into that application.
That won't work.

So within a major version we guarantee APIs to be backwards compatible,
but not forward compatible.
Newer releases might **add to** an API, but they should not alter or remove.

=== SPI

SPI contracts are stable across all releases within a *minor* version,
but not necessarily across different minors of the same major.

For example, an integration developed against Hibernate ORM 4.0.0 will work with 4.0.1 or 4.0.3,
but not necessarily with 4.1.0.

We do strive to maintain backwards compatibility for SPI contracts across minor versions,
it is just not guaranteed.

=== Internals

Users should have no expectations of any kind for compatibility when it comes to "internal" code.
Internal classes may be altered or even removed at any time, including in micro updates.
