= Migration Guide from Hibernate Search {from_version_short} to {to_version_short}
Yoann Rodi√®re
:awestruct-layout: project-standard
:awestruct-project: search
:toc:
:toc-placement: preamble
:toc-title: Content
:to_version_short: 6.0
:from_version_short: 5.11
:reference_version_full: 6.0.0.Beta11
:hsearch-doc-url-prefix: https://docs.jboss.org/hibernate/search/6.0/reference/en-US/html_single/
:hsearch-jira-url-prefix: https://hibernate.atlassian.net/browse

Here we are helping you migrate your existing Search application to the latest and greatest.

== Upgrade to Hibernate Search {to_version_short}.x from {from_version_short}.x

The aim of this guide is to assist you migrating
an existing application using any version `{from_version_short}.x` of Hibernate Search
to the latest of the `{to_version_short}.x` series.
If you're looking to migrate different versions see link:/search/documentation/migrate[Hibernate Search migration guides].

NOTE: This document provides pointers for a migration.
It refers to Hibernate Search version `{reference_version_full}`.
If you think something is missing or something does not work, please link:/community[contact us].

[IMPORTANT]
====
Search 6 introduces new APIs, so migrating older projects will be more work than usual.

We provide an additional "migration helper" module
that will allow you to use the Search 5 APIs with Search 6 and a Lucene backend under the hood.
However, this module does not offer full backward compatibility: for some features that changed dramatically,
it may not be possible to use the Search 5 APIs anymore.
See <<migration-helper>> for more information.

Finally, for those who cannot afford to, or do not want to, spend the time required to migrate,
we intend to continue maintenance releases (= bugfixes) of Hibernate Search 5.x:
no end-of-life date has been set at the moment.
====

[[requirements]]
=== Requirements

Hibernate Search 6 is still compatible with both JDK8 and JDK11.

The required versions of dependencies changed:

* The Hibernate ORM mapper now requires Hibernate ORM 5.4.4.Final or later
(5.4.3.Final and earlier won't work correctly).
* The Elasticsearch backend now requires Elasticsearch 5.6, 6.8 or 7.9.
* The Lucene backend now requires Lucene 8.6.

[[maven-coordinates]]
=== Maven coordinates changes

If you pull Hibernate Search artifacts from a Maven repository and you come from Hibernate Search 5,
be aware that just bumping the version number will not be enough:

* the group IDs changed from `org.hibernate` to `org.hibernate.search`
* most of the artifact IDs changed to reflect the new mapper/backend design
* the Lucene integration now requires an explicit dependency instead of being pulled by the engine by default.

Read the link:{hsearch-doc-url-prefix}#getting-started-dependencies[getting started guide, section "dependencies"]
for more information.

[[data-format]]
=== Data format changes

Indexes created with Hibernate Search 5 or earlier are not compatible with Hibernate Search 6.
This goes for embedded-Lucene indexes as well as Elasticsearch indexes.

In order to upgrade an application to Hibernate Search 6, all data must be reindexed.
See link:{hsearch-doc-url-prefix}#mapper-orm-indexing-massindexer[the documentation of the `MassIndexer`]
for instructions.

[[migration-helper]]
=== Migration helper

==== Purpose

Hibernate Search 6 includes a temporary additional "migration helper" module
that provides partial compatibility with Hibernate Search 5 APIs backed by the Hibernate Search 6 implementations.

This module should make migration easier by making sure that code relying on the most-frequently-used APIs
(mapping annotations, search DSL, ...)
continues to compile and run.
The idea is to use the migration helper temporarily to make most of the application code (search queries, ...) work,
making it easier to focus on migrating configuration and to assess the effort required to migrate the remaining code.

[IMPORTANT]
====
The migration helper should not be used in production environments.

It has limitations preventing full compatibility with Hibernate Search 5,
and these limitations will never be addressed.

All APIs defined in the migration helper are deprecated and will be removed in the next major version
of Hibernate Search.
====

==== How to use the migration helper

To use the migration helper, add the following dependency to your project:

[source, XML, subs="+attributes"]
----
<dependency>
   <groupId>org.hibernate.search</groupId>
   <artifactId>hibernate-search-v5migrationhelper-orm</artifactId>
   <version>{reference_version_full}</version>
</dependency>
----

Then, try to recompile your application.
Compilation errors should point you to the most significant API changes that require your immediate attention;
most of the code that still compiles should work as it used to in Hibernate Search 5.

[NOTE]
====
The migration helper only addresses Java API compatibility.
This excludes in particular:

* Configuration properties: they must still be <<configuration,replaced with Search 6 properties>>.
* Data format: data must still be <<data-format,reindexed>>.
====

[[configuration]]
=== Configuration changes

==== In brief

Most configuration properties changed in Hibernate Search 6.
In most cases it's only a matter of changing the prefix of a configuration property
(due to the different structure of Hibernate Search 6),
but in a few cases the relevant feature changed so much that a new approach was necessary for configuration.

For a quick introduction to the basics of configuration in Hibernate Search 6,
refer to the link:{hsearch-doc-url-prefix}#getting-started-configuration[getting started guide, section "configuration"].

For more details,
see the link:{hsearch-doc-url-prefix}#configuration[main "configuration" section of the reference documentation].

For a complete list of Hibernate Search 5 properties and their equivalent in Hibernate Search 6,
refer to the section below.

==== Configuration property reference

Below is a list of Hibernate Search 5 properties in alphabetical order,
along with their equivalent in Hibernate Search 6.

[WARNING]
====
Index defaults are no longer specified using the prefix `hibernate.search.default.`,
and `hibernate.search.indexes.default.` will not work either.

To specify configuration to be applied by default to all indexes,
just set the configuration at the backend level using the prefix `hibernate.search.backend.`.
====

`hibernate.search.analyzer`::
No direct equivalent in Hibernate Search 6.
+
To override the default analyzer, define a custom analyzer named `default`.
See <<analysis-definition-provider>>.
`hibernate.search.autoregister_listeners`::
Hibernate Search 6 equivalent: `hibernate.search.enabled`.
`hibernate.search.batch_size`::
No direct equivalent in Hibernate Search 6.
+
This property was not documented in Hibernate Search 5.
For the specific use case of batch processes,
know that upon Hibernate ORM session flushes,
Hibernate Search 6 will automatically turn entities to documents
and hold documents in memory until the transaction commit.
+
See also link:{hsearch-doc-url-prefix}#mapper-orm-indexing-manual[this section of the documentation].
`hibernate.search.default.elasticsearch.connection_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.connection_timeout`.
+
NOTE: Defaults to 1000 (1 second) in Hibernate Search 6 instead of 3 seconds in Hibernate Search 5.
More information https://in.relation.to/2020/09/07/hibernate-search-6-0-0-Beta10/#improved-timeouts[here].
`hibernate.search.default.elasticsearch.discovery.default_scheme`::
Hibernate Search 6 equivalent: `hibernate.search.backend.protocol`.
`hibernate.search.default.elasticsearch.discovery.enabled`::
Hibernate Search 6 equivalent: `hibernate.search.backend.discovery.enabled`.
`hibernate.search.default.elasticsearch.discovery.refresh_interval`::
Hibernate Search 6 equivalent: `hibernate.search.backend.discovery.refresh_interval`.
`hibernate.search.default.elasticsearch.dynamic_mapping`, `hibernate.search.<index-name>.elasticsearch.dynamic_mapping`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.dynamic_mapping`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.dynamic_mapping`.
`hibernate.search.default.elasticsearch.host`::
Hibernate Search 6 equivalent: `hibernate.search.backend.hosts`.
+
IMPORTANT: In Hibernate Search 6, the URL scheme (`http://` or `https://`) must *not* be included here.
Instead, set the property `hibernate.search.backend.protocol` to either `http` (the default) or `https`.
`hibernate.search.default.elasticsearch.index_management_wait_timeout`, `hibernate.search.<index-name>.elasticsearch.index_management_wait_timeout`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.schema_management.minimal_required_status_wait_timeout`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.schema_management.minimal_required_status_wait_timeout`.
`hibernate.search.default.elasticsearch.index_schema_management_strategy`, `hibernate.search.<index-name>.elasticsearch.index_schema_management_strategy`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.schema_management.strategy`.
+
Hibernate Search 6 equivalent (per-index): none.
+
Defaults to `create-or-validate` in Hibernate Search 6.
See link:{hsearch-doc-url-prefix}#mapper-orm-schema-management-strategy[schema management].
+
There is no direct equivalent for the per-index variant in Hibernate Search 6:
automatic schema management is configured globally for all indexes, not on a per-index basis.
However, you can achieve more control by setting `hibernate.search.schema_management.strategy` to `none`
and link:{hsearch-doc-url-prefix}#mapper-orm-schema-management-manager[managing the schema manually after startup].
`hibernate.search.default.elasticsearch.max_total_connection_per_route`::
Hibernate Search 6 equivalent: `hibernate.search.backend.max_connections_per_route`.
`hibernate.search.default.elasticsearch.max_total_connection`::
Hibernate Search 6 equivalent: `hibernate.search.backend.max_connections`.
`hibernate.search.default.elasticsearch.password`::
Hibernate Search 6 equivalent: `hibernate.search.backend.password`.
`hibernate.search.default.elasticsearch.path_prefix`::
No equivalent in Hibernate Search 6 link:{hsearch-jira-url-prefix}/HSEARCH-4051[yet].
`hibernate.search.default.elasticsearch.read_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.read_timeout`.
+
NOTE: Defaults to 30000 (30 seconds) in Hibernate Search 6 instead of 60 seconds in Hibernate Search 5.
More information https://in.relation.to/2020/09/07/hibernate-search-6-0-0-Beta10/#improved-timeouts[here].
`hibernate.search.default.elasticsearch.refresh_after_write`, `hibernate.search.<index-name>.elasticsearch.refresh_after_write`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.automatic_indexing.synchronization.strategy`.
+
Hibernate Search 6 equivalent (per-index): none.
+
Setting `hibernate.search.automatic_indexing.synchronization.strategy` to `read-sync` or `sync` will produce results
similar to setting `hibernate.search.default.elasticsearch.refresh_after_write` to `true`.
See link:{hsearch-doc-url-prefix}#mapper-orm-indexing-automatic-synchronization[automatic indexing synchronization]
for more information.
+
There is no equivalent for the per-index variant in Hibernate Search 6:
the synchronization strategy can only be set globally, not on a per-index basis.
`hibernate.search.default.elasticsearch.request_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.request_timeout`.
+
NOTE: Defaults to no timeout in Hibernate Search 6.
More information https://in.relation.to/2020/09/07/hibernate-search-6-0-0-Beta10/#improved-timeouts[here].
`hibernate.search.default.elasticsearch.required_index_status`, `hibernate.search.<index-name>.elasticsearch.required_index_status`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.schema_management.minimal_required_status`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.schema_management.minimal_required_status`.
`hibernate.search.default.elasticsearch.username`::
Hibernate Search 6 equivalent: `hibernate.search.backend.username`.
`hibernate.search.default.exclusive_index_use`, `hibernate.search.<index-name>.exclusive_index_use`::
No equivalent in Hibernate Search 6.
`hibernate.search.default.indexBase`, `hibernate.search.<index-name>.indexBase`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.directory.root`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.directory.root`.
`hibernate.search.default.indexName`, `hibernate.search.<index-name>.indexName`::
No equivalent in Hibernate Search 6.
+
The name of an index can still be customized in the mapping, using `@Indexed(name = ...)`,
or with the <<mapping-programmatic,programmatic>> equivalent.
`hibernate.search.default.index_flush_interval`, `hibernate.search.<index-name>.index_flush_interval`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.io.commit_interval`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index name>.io.commit_interval`.
`hibernate.search.default.index_metadata_complete`, `hibernate.search.<index-name>.index_metadata_complete`::
No equivalent in Hibernate Search 6.
+
This property was not documented in Hibernate Search 5.
`hibernate.search.default.indexmanager`, `hibernate.search.<index-name>.indexmanager`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.type`.
+
Hibernate Search 6 equivalent (per-index): none.
+
Setting the backend type (`elasticsearch` or `lucene`) should no longer be necessary:
it will be picked automatically if there is only one backend type available in the classpath.
+
If you have multiple backend types available in the classpath for some reason,
but only want to use one, set `hibernate.search.backend.type` to either `lucene` or `elasticsearch`.
+
If you need both a Lucene backend and an Elasticsearch backend, proceed as follows:

* Annotate entities that must be indexed in the Elasticsearch backend with `@Indexed(backend = "elasticsearch")`.
* Annotate entities that must be indexed in the Lucene backend with `@Indexed(backend = "lucene")`.
* Configure two separate backends in your configuration properties:
** prefix properties of the Elasticsearch backend with
`hibernate.search.backends.elasticsearch.` instead of `hibernate.search.backend.`.
** prefix properties of the Lucene backend with
`hibernate.search.backends.lucene.` instead of `hibernate.search.backend.`.
** same goes for indexes,
e.g. `hibernate.search.backends.elasticsearch.indexes.<index-name>.someProperty`
for indexes of the Elasticsearch backend
or `hibernate.search.backends.lucene.indexes.<index-name>.someProperty`
for indexes of the Lucene backend.
`hibernate.search.default.indexwriter.*`, `hibernate.search.<index-name>.indexwriter.*`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.io.writer.*` or `hibernate.search.backend.io.merge.*`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.io.writer.*` or `hibernate.search.backend.indexes.<index-name>.io.merge.*`.
+
The writer settings and merge settings are now split.
See link:{hsearch-doc-url-prefix}#backend-lucene-io-writer[here for available writer settings]
and link:{hsearch-doc-url-prefix}#backend-lucene-io-merge[here for available merge settings].
`hibernate.search.default.locking_strategy`, `hibernate.search.<index-name>.locking_strategy`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.directory.locking.strategy`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.directory.locking.strategy`.
+
See link:{hsearch-doc-url-prefix}#backend-lucene-configuration-directory-locking-strategy[here for available locking strategies].
`hibernate.search.default.max_queue_length`, `hibernate.search.<index-name>.max_queue_length`::
Hibernate Search 6 equivalent (global defaults): `hibernate.search.backend.indexing.queue_size`.
+
Hibernate Search 6 equivalent (per-index): `hibernate.search.backend.indexes.<index-name>.indexing.queue_size`.
+
IMPORTANT: In Hibernate Search 6, there are multiple queues per index, enabling parallel indexing of documents.
See link:{hsearch-doc-url-prefix}#backend-lucene-indexing-queues[here for Lucene]
or link:{hsearch-doc-url-prefix}#backend-elasticsearch-indexing-queues[here for Elasticsearch].
`hibernate.search.default_null_token`::
No equivalent in Hibernate Search 6.
+
In most cases, you <<field-indexnullas,won't need to use `indexNullAs` anymore>>.
Where `indexNullAs` is still needed, define the token explicitly for each index field.
`hibernate.search.default.reader.*`, `hibernate.search.<index-name>.reader.*`::
No direct equivalent in Hibernate Search 6.
+
To enable async reader refresh, set `hibernate.search.backend.io.refresh_interval` or
`hibernate.search.backend.indexes.<index-name>.io.refresh_interval`
to a strictly positive value (in milliseconds).
See link:{hsearch-doc-url-prefix}#backend-lucene-io-refresh[here for more information].
+
Custom reader strategies are no longer supported.
`hibernate.search.default.retry_marker_lookup`, `hibernate.search.<index-name>.retry_marker_lookup`::
No equivalent in Hibernate Search 6: <<search-5-backends,the `filesystem-slave` backend is no longer supported>>.
`hibernate.search.default.similarity`, `hibernate.search.<index-name>.similarity`::
No direct equivalent in Hibernate Search 6: the similarity is configured through the <<analysis-definition-provider,analysis configurer>>.
`hibernate.search.default.worker.backend`, `hibernate.search.<index-name>.worker.backend`::
No equivalent in Hibernate Search 6: <<search-5-backends,the JMS/JGroups/`filesystem-slave`/`filesystem-master`/`infinispan` backends are no longer supported>>.
`hibernate.search.default.worker.execution`, `hibernate.search.<index-name>.worker.execution`::
No direct equivalent in Hibernate Search 6.
+
Setting `hibernate.search.automatic_indexing.synchronization.strategy` to `async` or `sync` will produce results
similar to setting `hibernate.search.<index-name>.worker.execution` to the same value.
See link:{hsearch-doc-url-prefix}#mapper-orm-indexing-automatic-synchronization[automatic indexing synchronization]
for more information.
`hibernate.search.default.worker.*`, `hibernate.search.<index-name>.worker.*`::
No equivalent in Hibernate Search 6: <<search-5-backends,the JMS/JGroups/`filesystem-slave`/`filesystem-master`/`infinispan` backends are no longer supported>>.
`hibernate.search.elasticsearch.analysis_definition_provider`::
Hibernate Search 6 equivalent: `hibernate.search.backend.analysis.configurer`.
+
IMPORTANT: A different interface should be implemented: see <<analysis-definition-provider>>.
`hibernate.search.elasticsearch.log.json_pretty_printing`::
Hibernate Search 6 equivalent: `hibernate.search.backend.log.json_pretty_printing`.
`hibernate.search.elasticsearch.scroll_backtracking_window_size`::
No equivalent in Hibernate Search 6: scrolling is forward-only.
`hibernate.search.elasticsearch.scroll_fetch_size`::
No direct equivalent in Hibernate Search 6.
+
When using Hibernate Search APIs, the "chunk size" is an argument to the
link:{hsearch-doc-url-prefix}#search-dsl-query-fetching-results-scrolling[`scroll` method].
When using the link:{hsearch-doc-url-prefix}#search-dsl-query-object[Hibernate ORM or JPA adapters],
the "chunk size" is set to the same value as the link:{hsearch-doc-url-prefix}#search-dsl-query-fetch-size[fetch size].
`hibernate.search.elasticsearch.scroll_timeout`::
Hibernate Search 6 equivalent: `hibernate.search.backend.scroll_timeout`.
`hibernate.search.enable_dirty_check`::
Hibernate Search 6 equivalent: `hibernate.search.automatic_indexing.enable_dirty_check`.
`hibernate.search.error_handler`::
Hibernate Search 6 equivalent: `hibernate.search.background_failure_handler`.
+
IMPORTANT: A different interface should be implemented: see <<error-handler>>.
`hibernate.search.filter.cache_docidresults.size`::
No equivalent in Hibernate Search 6. See <<full-text-filter>>.
`hibernate.search.filter.cache_strategy`::
No equivalent in Hibernate Search 6. See <<full-text-filter>>.
`hibernate.search.generate_statistics`::
No equivalent in Hibernate Search 6. See <<statistics>>.
`hibernate.search.index_uninverting_allowed`::
Index uninverting was deprecated in Hibernate Search 5 due to poor performance and is no longer allowed.
All index fields that you want to sort on must be <<sortablefield,marked as sortable>>.
`hibernate.search.indexing_strategy`::
Hibernate Search 6 equivalent: `hibernate.search.automatic_indexing.strategy`.
+
Set to `none` to get the equivalent of `hibernate.search.indexing_strategy = manual` in Hibernate Search 5.
`hibernate.search.jmx_bean_suffix`::
No equivalent in Hibernate Search 6. See <<jmx>>.
`hibernate.search.jmx_enabled`::
No equivalent in Hibernate Search 6. See <<jmx>>.
`hibernate.search.lucene.analysis_definition_provider`::
Hibernate Search 6 equivalent: `hibernate.search.backend.analysis.configurer`.
+
IMPORTANT: A different interface should be implemented: see <<analysis-definition-provider>>.
`hibernate.search.lucene_version`::
Hibernate Search 6 equivalent: `hibernate.search.backend.lucene_version`.
`hibernate.search.model_mapping`::
Hibernate Search 6 equivalent: `hibernate.search.mapping.configurer`.
+
IMPORTANT: A different interface should be implemented: see <<mapping-programmatic>>.
`hibernate.search.query.database_retrieval_method`::
No equivalent in Hibernate Search 6: entities are always loaded with a query.
`hibernate.search.query.object_lookup_method`::
Hibernate Search 6 equivalent: `hibernate.search.query.loading.cache_lookup.strategy`.
+
See link:{hsearch-doc-url-prefix}#search-dsl-query-cache-lookup-strategy[this section of the documentation].
`hibernate.search.similarity`::
No direct equivalent in Hibernate Search 6: the similarity is configured through the <<analysis-definition-provider,analysis configurer>>.
`hibernate.search.worker.*`::
No equivalent to the concept of "worker" in Hibernate Search 6:
* automatic indexing is link:{hsearch-doc-url-prefix}#mapper-orm-indexing-automatic-concepts[always performed on transaction commit or,
when there is no transaction, on session flush].
* <<search-5-backends,transactional backends, for example the JMS backend, are no longer supported>>.

[[api]]
=== API changes

A lot of APIs changed. We recommend having a look at
link:{hsearch-doc-url-prefix}#getting-started[the getting started guide] before migrating.

[[mapping-annotations]]
==== Mapping annotations

[[analyzer]]
===== `@Analyzer`

In Hibernate Search 5, it was possible to apply an `@Analyzer` annotation to a class or property,
so that the corresponding analyzer would be used by default for any index field declared in this scope.

There is no equivalent to that feature in Hibernate Search 6:
all fields must specify their analyzer explicitly using `@FullTextField(analyzer = "myAnalyzer")`,
or rely on the (global) default analyzer.

Also, still in Hibernate Search 5, `@Analyzer` could point directly to a class extending `org.apache.lucene.analysis.Analyzer`,
for example with `@Analyzer(impl = StandardAnalyzer.class)`.

This is no longer possible: analyzers are now always referenced by their name.
However, you can assign a name to a given analyzer instance using
the link:{hsearch-doc-url-prefix}#backend-lucene-analysis-analyzers[Lucene analysis configurer].

[[analyzerdef]]
===== `@AnalyzerDef`

Annotation-based analyzer definitions are no longer supported.

Instead, implement an analysis configurer:
see link:{hsearch-doc-url-prefix}#backend-lucene-analysis-analyzers[here for Lucene],
or link:{hsearch-doc-url-prefix}#backend-elasticsearch-analysis-analyzers[here for Elasticsearch].

[[analyzerdiscriminator]]
===== `@AnalyzerDiscriminator`

`@AnalyzerDiscriminator` has no direct equivalent in Hibernate Search 6:
the analyzer assigned to each field is static and cannot change at runtime,
because that results in unreliable matches and in scoring issues.

Instead, Hibernate Search 6 allows declaring multiple index fields for a single property,
and putting the content of that property in a different field depending on a discriminator.
Then, when searching, you can target all fields at once.

See link:{hsearch-doc-url-prefix}#mapper-orm-alternatives[Mapping multiple alternatives].

[[boost]]
===== `@Boost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hsearch-doc-url-prefix}#search-dsl-predicate-common-boost[query-time boosting].

[[cachefromindex]]
===== `@CacheFromIndex`

This annotation was deprecated and non-functional in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

[[calendarbridge]]
===== `@CalendarBridge`

`@CalendarBridge` is not necessary to index `Calendar` values:
you can simply apply `@GenericField` to a property of type `Calendar`,
and an appropriate default bridge will be used.

The main purpose of `@CalendarBridge` in Hibernate Search 5 was to provide the ability
to "truncate" calendars upon indexing, e.g. zeroing out all data more precise than the day
with `@CalendarBridge(resolution = Resolution.DAY)`.

For such use case, the recommended approach in Hibernate Search 6 is to index values with full resolution
(not using `@CalendarBridge`) and to control resolution when searching,
with a link:{hsearch-doc-url-prefix}#search-dsl-predicate-range[`range` predicate].
Note that you can pass `ZonedDateTime` values to the predicate, which are much easier to truncate manually.
For example, to match only documents whose calendar is within a given day:

[source, JAVA]
----
Calendar toMatch = /* ... */;
ZonedDateTime toMatchZonedDateTime = ( (GregorianCalendar) toMatch ).toZonedDateTime();
ZonedDateTime dayStart = toMatchZonedDateTime.truncatedTo( ChronoUnit.DAYS );
ZonedDateTime nextDayStart = dayStart.plus( 1, ChronoUnit.DAYS );

List<MyEntity> hits = searchSession.search( MyEntity.class )
        .where( f -> f.range().field( "calendar" )
                .range( Range.canonical( dayStart, nextDayStart ), ValueConvert.NO )
        .fetchHits( 20 );
----

If that approach doesn't work for you, link:/community/[let us know] and we'll try to come up with a solution together.

[[charfilterdef]]
===== `@CharFilterDef`

See <<analyzerdef>> or <<normalizerdef>>.

[[classbridge]]
===== `@ClassBridge`, `@ClassBridges`

See <<bridges>>.

[[containedin]]
===== `@ContainedIn`

`@ContainedIn` is no longer necessary in Hibernate Search 6.

Hibernate Search 6 infers indexing dependencies from the mapping,
and raises errors at bootstrap when the equivalent of `@ContainedIn` cannot be applied automatically
(for example an `@IndexedEmbedded` association with no inverse side).

The error message includes potential solutions. It looks like this:

> Cannot find the inverse side of the association on type 'MyIndexedType' at path '.myIndexedEmbedded<no value extractors>'
> Hibernate Search needs this information in order to reindex 'MyIndexedType' when 'MyIndexedEmbeddedType' is modified.
> You can solve this error by defining the inverse side of this association,
> either with annotations specific to your integration (`@OneToMany(mappedBy = ...)` in Hibernate ORM)
> or with the Hibernate Search `@AssociationInverseSide` annotation.
> Alternatively, if you do not need to reindex 'MyIndexedType' when 'MyIndexedEmbeddedType' is modified,
> you can disable automatic reindexing with `@IndexingDependency(reindexOnUpdate = ReindexOnUpdate.SHALLOW)`.

Thus, the recommended approach when migrating is to simply remove all `@ContainedIn` annotations,
then deal with the bootstrap errors, if any.

TIP: Hibernate Search 6 is able to raise multiple mapping errors during a single startup,
so you don't have to restart the application 20 times to address 20 different problems.

[[datebridge]]
===== `@DateBridge`

`@DateBridge` is not necessary to index `Date` values:
you can simply apply `@GenericField` to a property of type `java.util.Date`, `java.sql.Date`, `java.sql.Time` or `java.sql.Timestamp`,
and an appropriate default bridge will be used.

The main purpose of `@DateBridge` in Hibernate Search 5 was to provide the ability
to "truncate" dates upon indexing, e.g. zeroing out all data more precise than the day
with `@DateBridge(resolution = Resolution.DAY)`.

For such use case, the recommended approach in Hibernate Search 6 is to index values with full resolution
(not using `@DateBridge`) and to control resolution when searching,
with a link:{hsearch-doc-url-prefix}#search-dsl-predicate-range[`range` predicate].
Note that you can pass `Instant` values to the predicate, which are much easier to truncate manually.
For example, to match only documents whose date is within a given day:

[source, JAVA]
----
Date toMatch = /* ... */;
ZoneId userZoneId = /* ... */;
ZonedDateTime toMatchZonedDateTime = Instant.ofEpochMilli( toMatch.getTime() ).atZone( userZoneId );
ZonedDateTime dayStart = toMatchZonedDateTime.truncatedTo( ChronoUnit.DAYS );
ZonedDateTime nextDayStart = dayStart.plus( 1, ChronoUnit.DAYS );

List<MyEntity> hits = searchSession.search( MyEntity.class )
        .where( f -> f.range().field( "date" )
                .range( Range.canonical( dayStart.toInstant(), nextDayStart.toInstant() ),
                        ValueConvert.NO )
        .fetchHits( 20 );
----

If that approach doesn't work for you, link:/community/[let us know] and we'll try to come up with a solution together.

[[documentid]]
===== `@DocumentId`

`@DocumentId` is still available in Hibernate Search 6.

However, it no longer exposes a `name` attribute,
because <<document-id-is-not-a-field,the document ID is no longer an index field>>,
and thus it does not need a name.

[[dynamicboost]]
===== `@DynamicBoost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hsearch-doc-url-prefix}#search-dsl-predicate-common-boost[query-time boosting].

[[facet]]
===== `@Facet`, `@Facets`

Facets were replaced with aggregations, which are a generalization of the concept of faceting.

To make a field aggregable, just set the `@*Field.aggregable` attribute to `Aggregable.YES`:

[source, JAVA]
----
@KeywordField(aggregable = Aggregable.YES)
private String myKeyword;
@GenericField(aggregable = Aggregable.YES)
private Integer myInteger;
@GenericField(aggregable = Aggregable.YES)
private LocalDate myLocalDate;
----

[NOTE]
====
The facet encoding options no longer exists:
strings will be indexed as strings and numbers will be indexed as numbers.

For the few cases where encoding a number as a string is necessary,
you can define a separate field exclusively for aggregations,
and apply a link:{hsearch-doc-url-prefix}#mapper-orm-bridge-valuebridge[custom value bridge]
to convert the number to a string (and back).
====

[NOTE]
====
`aggregable` is not available on `@FullTextField`,
because aggregation on a tokenized field would aggregate tokens instead of field values,
which is rarely the intent.

If you need both an analyzer and aggregations on the same property, create two separate fields:

[source, JAVA]
----
@FullTextField
@KeywordField(name = "category_aggregation", aggregable = Aggregable.YES)
private String category;
----

For instructions on how to execute aggregations, see <<searching-facet>>.

This will lead to two separate fields being created in the index, for the same property.
Just make sure to use the correct field name when searching:
`category` when creating link:{hsearch-doc-url-prefix}#search-dsl-predicate-match[predicates],
but `category_aggregation` when creating link:{hsearch-doc-url-prefix}#search-dsl-aggregation-terms[aggregations].
====

The `@Field` annotation was split into multiple annotations, specific to each field type.

[[field]]
===== `@Field`, `@Fields`

The `@Field` annotation was split into multiple annotations, specific to each field type.

[[field-basics]]
====== Basics

Here is a quick reference of how to convert a `@Field` annotation to Hibernate Search 6:

[cols="1,l,l",options="header"]
|====
|Property type|Hibernate Search 5|Hibernate Search 6
|`String`, `Character`, `char`, enum|@Field|@FullTextField
|`String`, `Character`, `char`, enum|@Field(analyzer = @Analyzer(definition = "myAnalyzer")) .2+|@FullTextField(analyzer = "myAnalyzer")
|`String`, `Character`, `char`, enum|@Field
@Analyzer(definition = "myAnalyzer")
|`String`, `Character`, `char`, enum|@Field(normalizer = @Normalizer(definition = "myNormalizer"))|@KeywordField(normalizer = "myNormalizer")
|`String`, `Character`, `char`, enum|@Field(analyze = analyze.NO)|@KeywordField
|Other|@Field @NumericField|@GenericField
|Other|@Field|@GenericField
|====

[[field-analyze]]
====== `@Field.analyze`

`@Field.analyze` has no direct equivalent in Hibernate Search 6.
Instead of enabling/disabling analysis explicitly,
<<field-basics,pick the right `@*Field` annotation according to your needs>>.

[[field-analyzer]]
====== `@Field.analyzer`

See <<field-basics>>.

[[field-boost]]
====== `@Field.boost`

Index-time boosting was deprecated in Hibernate Search 5.
It is no longer available in Hibernate Search 6.

Instead, rely on link:{hsearch-doc-url-prefix}#search-dsl-predicate-common-boost[query-time boosting].

[[field-bridge]]
====== `@Field.bridge`

See <<bridges>>.

[[field-index]]
====== `@Field.index`

`@Field.index` is now `@*Field.searchable`:

[cols="l,l",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|@Field(index = Index.YES)|@GenericField(searchable = Searchable.YES)
OR @FullTextField(searchable = Searchable.YES)
OR @KeywordField(searchable = Searchable.YES)
|@Field(index = Index.NO)|@GenericField(searchable = Searchable.NO)
OR @FullTextField(searchable = Searchable.NO)
OR @KeywordField(searchable = Searchable.NO)
|====

[[field-indexnullas]]
====== `@Field.indexNullAs`

`@Field.indexNullAs` is still available for most Hibernate Search 6's `@*Field` annotations:

[cols="l,l",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|@Field(indexNullAs = "_null_")|@GenericField(indexNullAs = "_null_")
OR @KeywordField(indexNullAs = "_null_")
|====

However:

* Its usage is discouraged, as the new link:{hsearch-doc-url-prefix}#search-dsl-predicate-exists[`exists` predicate]
introduced in Hibernate Search 6 allows finding documents where a field is present or not
*without* relying on `indexNullAs`.
* `indexNullAs` is not available on `@FullTextField`.
* The default null token is no longer supported, i.e. `Field.DEFAULT_NULL_TOKEN` has no equivalent in Hibernate search 6.
Each field that requires `indexNullAs` must have its value set explicitly.
* The (text) value passed to `indexNullAs` must be link:{hsearch-doc-url-prefix}#mapper-orm-directfieldmapping-supported-types[formatted according to the type of the field].

[[field-name]]
====== `@Field.name`

`@Field.name` stays the same in Hibernate Search 6's `@*Field` annotations:

[cols="l,l",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|@Field(name = "myField")|@GenericField(name = "myField")
OR @FullTextField(name = "myField")
OR @KeywordField(name = "myField")
|====

[[field-normalizer]]
====== `@Field.normalizer`

See <<field-basics>>.

[[field-norms]]
====== `@Field.norms`

`@Field.norms` only has an equivalent in Hibernate Search 6's `@FullTextField` and `@KeywordField`.
The `Norms` enum has moved to `org.hibernate.search.engine.backend.types.Norms`.

[[field-store]]
====== `@Field.store`

`@Field.store` is now `@*Field.projectable`:

[cols="l,l",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|@Field(store = Store.YES)|@GenericField(projectable = Projectable.YES)
OR @FullTextField(projectable = Projectable.YES)
OR @KeywordField(projectable = Projectable.YES)
|@Field(store = Store.NO)|@GenericField(projectable = Projectable.NO)
OR @FullTextField(projectable = Projectable.NO)
OR @KeywordField(projectable = Projectable.NO)
|====

[[field-termVector]]
====== `@Field.termVector`

`@Field.termVector` only has an equivalent in Hibernate Search 6's `@FullTextField`.
The `TermVector` enum has moved to `org.hibernate.search.engine.backend.types.TermVector`.

[[fieldbridge]]
===== `@FieldBridge`

See <<bridges>>.

[[fulltextfilterdef]]
===== `@FullTextFilterDef`, `@FullTextFilterDefs`

Full-text filters have no direct equivalent in Hibernate Search 6.

See <<full-text-filter>>.

[[indexed]]
===== `@Indexed`

NOTE: In Hibernate Search 6, <<indexed-is-inherited,`@Indexed` is inherited>>.

[[normalizer]]
===== `@Normalizer`

In Hibernate Search 5, `@Normalizer` could point directly to a class extending `org.apache.lucene.analysis.Analyzer`,
for example with `@Normalizer(impl = MyNormalizer.class)`.

This is no longer possible: normalizers are now always referenced by their name.
However, you can assign a name to a given normalizer instance using
the link:{hsearch-doc-url-prefix}#backend-lucene-analysis-analyzers[Lucene analysis configurer].

[[normalizerdef]]
===== `@NormalizerDef`

Annotation-based normalizer definitions are no longer supported.

Instead, implement an analysis configurer:
see link:{hsearch-doc-url-prefix}#backend-lucene-analysis-analyzers[here for Lucene],
or link:{hsearch-doc-url-prefix}#backend-elasticsearch-analysis-analyzers[here for Elasticsearch].

[[sortablefield]]
===== `@SortableField`

`@SortableField` no longer exists; instead, use `@*Field.sortable`:

[cols="l,l",options="header"]
|====
|Hibernate Search 5|Hibernate Search 6
|@Field @SortableField|@GenericField(sortable = Sortable.YES)
OR @KeywordField(sortable = Sortable.YES)
|====

[NOTE]
====
`sortable` is not available on `@FullTextField`,
because link:{hsearch-doc-url-prefix}#mapper-orm-directfieldmapping-annotations-fulltextfield[tokenized data cannot be reliably sorted on].

If you need both an analyzer and sorts on the same property, create two separate fields:

[source, JAVA]
----
@FullTextField
@KeywordField(name = "title_sort", normalizer = "myNormalizer", sortable = Sortable.YES)
private String title;
----

This will lead to two separate fields being created in the index, for the same property.
Just make sure to use the correct field name when searching:
`title` when creating link:{hsearch-doc-url-prefix}#search-dsl-predicate-match[predicates],
but `title_sort` when creating link:{hsearch-doc-url-prefix}#search-dsl-sort-field[sorts].
====

[[mapping-programmatic]]
==== Programmatic mapping

TODO

See link:{hsearch-doc-url-prefix}#mapper-orm-programmatic-mapping[here].

[[analysis-definition-provider]]
==== Analysis definition provider

Analysis definition providers are now called analysis configurers.
The interfaces are slightly different but follow the same general principle.

See link:{hsearch-doc-url-prefix}#backend-lucene-analysis-analyzers[here for Lucene],
or link:{hsearch-doc-url-prefix}#backend-elasticsearch-analysis-analyzers[here for Elasticsearch].

NOTE: Analysis configurers can be used to override the default analyzer.
To do so, just define a custom analyzer named `default`.

NOTE: With the Lucene backend, analysis configurers can be used to override the default similarity.
See link:{hsearch-doc-url-prefix}#backend-lucene-analysis-similarity[here for more information]

[[bridges]]
==== Bridges

The bridge API was completely reworked in Hibernate Search 6 to offer a more powerful, Lucene-independent solution.
New features include:

* the ability to link:{hsearch-doc-url-prefix}#mapper-orm-bridge-index-field-type-dsl[define field types precisely],
allowing in particular to pick an analyzer or to enable aggregation (faceting) on a bridge-declared field;
* the ability to link:{hsearch-doc-url-prefix}#mapper-orm-bridge-bridgedelement-dependencies[declare the properties the bridge relies on],
allowing Hibernate Search to reindex less often;
* the ability to link:{hsearch-doc-url-prefix}#mapper-orm-bridge-index-field-dsl-dynamic[declare dynamic fields with a precise type]
which the Search DSL will be aware of;
* the ability to link:{hsearch-doc-url-prefix}#mapper-orm-custom-annotations[define custom field annotations];
* and link:{hsearch-doc-url-prefix}#mapper-orm-bridge[more].

If your application relied on custom bridges with Hibernate Search 5,
and you need to re-implement them with Hibernate Search 6,
see link:{hsearch-doc-url-prefix}#mapper-orm-directfieldmapping-custom-types[mapping custom property types].

[[searching]]
==== Searching

TODO

[[searching-facet]]
===== Facets

TODO

[[error-handler]]
==== Error handler

TODO

[[full-text-filter]]
==== Full text filter

TODO

[[statistics]]
==== Statistics

TODO

[[jmx]]
==== JMX

TODO

[[search-5-backends]]
==== Backends

TODO

[[factory]]
==== `@Factory`

The `@Factory` annotation does not exist in Hibernate Search 6 anymore.

You are encouraged to rely on a proper dependency injection framework if you need such a feature:
just reference the bean name instead of referencing the bean class in your Hibernate Search mapping/configuration.
See link:{hsearch-doc-url-prefix}#configuration-bean[the section of the documentation about beans in Hibernate Search]
for details and supported DI frameworks.

If you don't use a dependency injection framework,
here are details on how to migrate:

String bridges, field bridges, class bridges::
Use their `*Binder` equivalent in Hibernate Search 6,
which can act as a factory:
link:{hsearch-doc-url-prefix}#mapper-orm-bridge-valuebridge-valuebinder[`ValueBinder`],
link:{hsearch-doc-url-prefix}#mapper-orm-bridge-propertybridge[`PropertyBinder`],
link:{hsearch-doc-url-prefix}#mapper-orm-bridge-typebridge[`TypeBinder`].

Full-text filters::
These no longer exist in Hibernate Search 6.
See link:{hsearch-jira-url-prefix}/HSEARCH-3325[HSEARCH-3325].

Programmatic mapping::
`@Factory` is no longer needed for the programmatic mapping,
since you will pass a callback (link:{hsearch-doc-url-prefix}#_configuring_the_mapping[`HibernateOrmSearchMappingConfigurer`])
instead of passing the mapping directly.
Whatever code was implemented in your factory can be moved to the configurer.

Analysis definition providers::
Analysis definition providers <<analysis-definition-provider,are now called analysis configurers>>,
and as they are just callbacks that are used only once,
the `@Factory` annotation should not be necessary.
Whatever code was implemented in your factory can be moved to the configurer.

[[spi]]
=== SPI changes

Due to the extensive rewrites involved in Hibernate Search 6,
existing integrations relying on Hibernate Search 5 are likely to require a full rewrite.
We will be glad to help, so feel free to link:/community[contact us].

[[behavior]]
=== Behavior changes

WARNING: This section is still incomplete. To be completed upon the CR or release.

==== Indexes can only contain one type

It is no longer possible to map multiple entity types to the same index.
Each index must be mapped to exactly one entity type.

==== No default bridge for `java.util.Class`

There is no longer a builtin, default bridge for `java.util.Class`.

If you need to index a `Class<?>`, you will need to write a
link:{hsearch-doc-url-prefix}#mapper-orm-bridge-valuebridge[custom bridge]
(probably from `Class` to `String`).

Optionally, you can also register your custom bridge as a
link:{hsearch-doc-url-prefix}#mapper-orm-bridge-resolver[default bridge]
so that it is applied automatically and transparently to all fields defined on properties of type `Class`.

[[document-id-is-not-a-field]]
==== The document ID is not an index field

TODO

[[indexed-is-inherited]]
==== `@Indexed` is inherited